/*
 * <copyright>
 *  Copyright 1997-2003 BBNT Solutions, LLC
 *  under sponsorship of the Defense Advanced Research Projects Agency (DARPA).
 * 
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Cougaar Open Source License as published by
 *  DARPA on the Cougaar Open Source Website (www.cougaar.org).
 * 
 *  THE COUGAAR SOFTWARE AND ANY DERIVATIVE SUPPLIED BY LICENSOR IS
 *  PROVIDED 'AS IS' WITHOUT WARRANTIES OF ANY KIND, WHETHER EXPRESS OR
 *  IMPLIED, INCLUDING (BUT NOT LIMITED TO) ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND WITHOUT
 *  ANY WARRANTIES AS TO NON-INFRINGEMENT.  IN NO EVENT SHALL COPYRIGHT
 *  HOLDER BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT OR CONSEQUENTIAL
 *  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE OF DATA OR PROFITS,
 *  TORTIOUS CONDUCT, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 *  PERFORMANCE OF THE COUGAAR SOFTWARE.
 * </copyright>
 */

package org.cougaar.core.mts.std;

import org.cougaar.core.service.*;

import org.cougaar.core.node.*;

import org.cougaar.core.mts.Message;
import org.cougaar.core.mts.MessageAddress;


import java.util.ArrayList;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

/**
 * A LinkSender is essentially just a thread whose job is to pop
 * messages off a DestinationQueue and forward them on to the
 * "cheapest" transport.  There's one LinkSender per DestinationQueue,
 * and they're created by a LinkSenderFactory.  */
public class LinkSender implements Runnable
{
    private static final int MAX_DELAY = 60 * 1000; // 1 minute
    private MessageAddress destination;
    private LinkProtocolFactory protocolFactory;
    private MessageTransportRegistry registry;
    private Thread thread;
    private DestinationQueue queue;
    private Object queueLock;
    private ArrayList destinationLinks;
    private LinkSelectionPolicy selectionPolicy;

    LinkSender(String name, 
	       MessageAddress destination, 
	       MessageTransportRegistry registry,
	       LinkProtocolFactory protocolFactory,
	       DestinationQueue queue,
	       Object queueLock,
	       LinkSelectionPolicy selectionPolicy) 
    {
	this.destination = destination;
	this.queue = queue;
	this.queueLock = queueLock;
	this.protocolFactory = protocolFactory;
	this.registry = registry;
	this.selectionPolicy = selectionPolicy;

	// cache DestinationLinks, per transport
	destinationLinks = new ArrayList();
	getDestinationLinks();
	

	thread = new Thread(this, name);
	thread.start();
    }




    /**
     * Here we ask each transport for DestinationLink.  The links will
     * be used later to find the cheapest transport for any given
     * message. */
    private void getDestinationLinks() 
    {
	Iterator itr = protocolFactory.getProtocols().iterator();
	DestinationLink link;
	while (itr.hasNext()) {
	    LinkProtocol lp = (LinkProtocol) itr.next();
	    // Class lp_class = lp.getClass();
	    link = lp.getDestinationLink(destination);
	    destinationLinks.add(link);
	}
    }


    /**
     * The thread body pops messages off the corresponding
     * DestinationQueue, finds the cheapest DestinationLink for that
     * message, and forwards the message to that link.  */
    public void run() {
	Message message = null;
	int delay = 500; // comes from a property
	Iterator links;
	DestinationLink link;
	while (true) {
	    synchronized (queueLock) {
		while (queue.isEmpty()) {
		    try { queueLock.wait(); } catch (InterruptedException e) {}
		}

		message = (Message) queue.next();
	    }
	    if (message != null) {
		MessageTransportServiceProxy serviceProxy =
		    registry.findServiceProxy(message.getOriginator());
		while (true) {
		    links = destinationLinks.iterator();
		    link = selectionPolicy.selectLink(links, message);
		    if (link != null) {
			try {
			    link.forwardMessage(message);
			    if (serviceProxy != null) 
				serviceProxy.messageDelivered(message);
			    break;
			} catch (UnregisteredNameException no_name) {
			    // nothing to say here
			} catch (NameLookupException lookup_error) {
			    lookup_error.printStackTrace();
			} catch (CommFailureException comm_failure) {
			    comm_failure.printStackTrace();
			} catch (MisdeliveredMessageException misd) {
			    System.err.println(misd);
			}
		    }

		    if (serviceProxy != null)
			if (serviceProxy.messageFailed(message)) break;

		    try { Thread.sleep(delay);}
		    catch (InterruptedException ex){}
		    if (delay < MAX_DELAY) delay += delay;
		}
	    }
	}
    }


}
